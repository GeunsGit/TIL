# MSA(MicroService Architecture)

## 학습하게 된 이유

공통 프로젝트를 진행하면서 아키텍처에 대한 특강을 들은 적이 있었다. 아키텍처 설계 실습을 통해 아키텍처에 대해 감을 어느정도 잡을 수 있었다.
사실 특강을 듣기 전까지는 아키텍처의 중요성이나 설계 방법, 사용방법에 대한 자세한 이해가 부족했고, 필요성을 크게 느끼지 못했었다.

여태 아키텍처를 그릴 때 단순 기술 나열만 해왔는데 아키텍처를 잘 설계하여 도식화하고, 그렇게 아키텍처를 설계한 이유를 잘 설명할 수 있다면
면접을 볼 때 남들보다 더 기억에 남을 수 있을 것 같다.

컨설턴트님께서 현업에서 ___99%는 마이크로 서비스 아키텍처를 사용할 것___ 이라고 말씀해주셨던 것이 기억에 남는다.
대부분의 서비스들이 규모가 크고 빠른 수정이 필요하니까 납득이 되었다. 그 정도로 많이 사용한다면 나도 이번 기회에 공부해서
MSA를 적용시킨다면 백엔드 개발자로서의 역량을 어필하는데 큰 도움이 되지 않을까? 하는 생각이 들기도 했다.

## SW 아키텍처 _(Architecture)_ 란 ?
소프트웨어 구성요소들 사이에서 유기적 관계를 표현하고, 소프트웨어의 설계와 업그레이드를 통제하는 지침과 원칙이다.

![image](https://user-images.githubusercontent.com/92859179/188485836-0deb3f62-c246-48b5-83ba-b24b3f6fa82a.png)

## 모놀리식 아키텍처 _(Monolithic Architecture)_
소프트웨어 프로그램의 전통적인 모델로, 자체 포함 방식이며 다른 애플리케이션과 독립적인 통합된 유닛으로 만들어지는 아키텍처이다.

### 모놀리식 아키텍처의 장점
- 손쉬운 배포 - 실행 파일 또는 디렉토리가 하나기 때문에 배포가 더 쉽다.
- 개발 - 하나의 코드 베이스로 애플리케이션을 구축하기 때문에 개발이 더 쉽다.
- 성능 - 중앙 집중식 코드 베이스 및 리포지토리에서는 하나의 API만으로 마이크로서비스에서 여러 API가 수행하는 것과 동일한 기능 수행이 가능하다.
- 테스트 간소화 - 중앙 집중식 장치기 때문에 분산된 애플리케이션보다 End-to-End 테스트가 빠르다.
- 간편한 디버깅 - 모든 코드가 한 곳에 있기 때문에 요청을 따라가며 문제 찾기가 쉽다.

### 모놀리식 아키텍처의 단점
- 느린 개발 속도 - 대규모 애플리케이션에서는 개발이 더욱 복잡해지고 속도가 느려진다.
- 확장성 - 개별 컴포넌트를 확장할 수 없다.
- 안정성 - 모듈에 오류가 있으면 애플리케이션 전체의 가용성에 영향을 줄 수 있다.
- 기술 채택의 장벽 - 프레임워크 또는 언어를 변경하면 애플리케이션 전체에 영향을 미쳐 비용과 시간이 많이 소요될 수 있다.
- 배포 - 약간만 변경해도 전체를 다시 배포해야 한다.

## 마이크로서비스 아키텍처 _(Microservice architecture)_
독립적으로 배포 가능한 일련의 서비스를 이용하는 아키텍처 방법이다.

### 마이크로서비스 아키텍처의 장점
- 지속적 배포 - 자주 릴리즈할 수 있고, 릴리즈 주기를 빠르게 할 수 있다.
- 유지보수와 테스트 편의성 - 새로운 기능 실험 후 문제 발생시 롤백할 수 있다. 이를 통해 코드를 보다 쉽게 업데이트하고 새로운 기능 출시 기간을 단축할 수 있다.
- 독립적 배포 - 모두 개별적인 모듈이기 때문에 개별 기능을 빠르고 쉽게 독립적으로 배포할 수 있다.
- 기술 유연성 - 팀에서 원하는 도구를 자유롭게 선택할 수 있다.
- 높은 안정성 - 애플리케이션 중단 위험 없이 특정 서비스에 대한 변경 사항을 배포할 수 있다.

### 마이크로서비스 아키텍처의 단점
- 무분결한 개발 확산 - 더 많은 곳에 더 많은 서비스를 만들기 때문에 모놀리식보다 복잡하다. 적절한 관리가 되지 않으면 개발 속도와 운영 성능이 저하될 수 있다.
- 인프라 비용 - 테스트 도구, 배포 플레이북, 호스팅 인프라, 모니터링 도구 등에 대한 자체적인 비용이 발생할 수 있다.
- 조직 오버헤드 - 추가적인 커뮤니케이션과 공동 작업이 이루어져야 한다.
- 디버깅 - 각 서비스가 자체적인 로그를 가지고 있어 디버깅이 더 복잡하다.

## 도커 ? 쿠버네티스 ?
![img_2](/uploads/a1f0b68e047bc978852a445f67d543e0/img_2.png)
- **Docker** : 마이크로서비스 아키텍처의 <u>세분화된 서비스와 컨테이너의 확장성과 장점</u>이 맞물리면서 주목을 받기 시작했고,
이 컨테이너들을 쉽게 관리, 배포할 수 있는 **Docker**가 주목을 받기 시작했다.
- **Kubernetes** : 프로젝트 규모가 커질수록 많아지는 컨테이너들을 Docker만으로 감당하기 어려워지기 시작했다.
그래서 등장한 것이 **컨테이너 오케스트레이션**이라는 개념인데, 컨테이너 오케스트레이션은 컨테이너가 대규모로 운영될 때 생기는
<u>스케줄링 문제나 관리 등을 지원해주는 도구</u>이다. 그 중 **Kubernetes**가 거의 표준처럼 사용된다고 한다.

## 느낀 점
- 러닝 커브가 상당히 높다고 느껴졌다. 클라우드와 컨테이너에 대한 개념과 이해도 필요하다. 설계는 정말 어렵구나..
- 조금은 욕심이 생긴다. 하지만.. ~~할 수 있을지에 대한 걱정감과 불안감도..~~
- 아직까지 제일 와닿는 장점은 배포에 대한 장점이다. 위험성이 확실히 줄어들 것 같다.
- API Gateway 는 어떤걸 쓰면 될까.. Spring Cloud Gateway ? 사실 아직도 학습이 더 필요하고 감이 안 잡히는 부분도 많다.

#### 레퍼런스
> https://www.atlassian.com/ko/microservices/microservices-architecture/microservices-vs-monolith